//! Set reconciliation network behavior

mod handler;
mod protocol;

use std::{
    collections::{BTreeSet, VecDeque},
    task::Poll,
};

use libp2p::{
    swarm::{
        derive_prelude::ConnectionId, ConnectionHandler, IntoConnectionHandler, NetworkBehaviour,
        NetworkBehaviourAction,
    },
    PeerId,
};
use rand::{thread_rng, RngCore};
use tracing::info;

use crate::handler::Handler;
pub use handler::{Config, Failure, Success};

pub use self::protocol::PROTOCOL_NAME;

/// The result of an inbound or outbound ping.
pub type Result = std::result::Result<Success, Failure>;

pub struct Behaviour {
    /// Configuration for outbound pings.
    config: Config,
    /// Queue of events to yield to the swarm.
    events: VecDeque<Event>,

    // Set to reconcile
    set: BTreeSet<u8>,
}

impl Behaviour {
    /// Creates a new `Ping` network behaviour with the given configuration.
    pub fn new(config: Config) -> Self {
        let mut set = [0u8; 10];
        thread_rng().fill_bytes(&mut set[..]);
        let set = set.into_iter().collect();
        info!("behaviour set: {:?}", set);
        Self {
            config,
            events: VecDeque::new(),
            set,
        }
    }
}
impl Default for Behaviour {
    fn default() -> Self {
        Self::new(Config::new())
    }
}

/// Event generated by the `Ping` network behaviour.
#[derive(Debug)]
pub struct Event {
    /// The peer ID of the remote.
    pub peer_id: PeerId,
    /// The result of an inbound or outbound ping.
    pub event: Result,
}

impl From<Event> for iroh_p2p::behaviour::Event<Behaviour> {
    fn from(value: Event) -> Self {
        Self::Custom(value)
    }
}
impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = Handler;

    type OutEvent = Event;

    fn new_handler(&mut self) -> Self::ConnectionHandler {
        Handler::new(self.config.clone(), self.set.clone())
    }

    fn on_connection_handler_event(
        &mut self,
        peer_id: PeerId,
        _connection_id: ConnectionId,
        event: <<Self::ConnectionHandler as IntoConnectionHandler>::Handler as
        ConnectionHandler>::OutEvent,
    ) {
        self.events.push_front(Event { peer_id, event })
    }

    fn poll(
        &mut self,
        _cx: &mut std::task::Context<'_>,
        _params: &mut impl libp2p::swarm::PollParameters,
    ) -> std::task::Poll<
        libp2p::swarm::NetworkBehaviourAction<Self::OutEvent, Self::ConnectionHandler>,
    > {
        if let Some(e) = self.events.pop_back() {
            let Event { peer_id, event } = &e;

            match event {
                Ok(Success::Set(set)) => {
                    self.set.extend(set.into_iter());
                    info!(
                        "Synchronized set with peer {:?} set: {:?}",
                        peer_id, self.set
                    )
                }
                _ => {}
            }

            Poll::Ready(NetworkBehaviourAction::GenerateEvent(e))
        } else {
            Poll::Pending
        }
    }
}
